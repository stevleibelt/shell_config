#!/bin/bash

####
# [@param string $FILE_NAME_PATTERN=*converted*]
# [@param string $WORKING_DIRECTORY_PATH=$(pwd)]
# [@param int $SIZE_THRESHOLD_LIMIT=2.7]
#
# [@flag -d     - enables dryrun]
# [@flag -v     - be verbose]
# [@flag -vv    - be more verbose]
# [@flag -vvv   - be verbosest!]
####
# @since 2018-10-04
# @author stev leibelt
####
function net_bazzline_cleanup_after_converting_files ()
{
    local IS_DRY_RUN=0;
    local LEVEL_OF_VERBOSITY=0;

    while  true;
    do
        case "${1}" in
            -d)
                IS_DRY_RUN=1
                shift
                ;;
            -v)
                LEVEL_OF_VERBOSITY=1
                shift
                ;;
            -vv)
                LEVEL_OF_VERBOSITY=2
                shift
                ;;
            -vvv)
                LEVEL_OF_VERBOSITY=3
                shift
                ;;
            *)
                break
                ;;
        esac
    done

    local FILE_NAME_PATTERN=${1:-'*converted*'}
    local SIZE_THRESHOLD_LIMIT=${3:-2.7}
    local WORKING_DIRECTORY_PATH=${2:-$(pwd)}

    local LENGTH_OF_THE_FILE_NAME_PATTERN=${#FILE_NAME_PATTERN}

    if [[ ${LEVEL_OF_VERBOSITY} -gt 2 ]];
    then
        echo "Working directory path >>${WORKING_DIRECTORY_PATH}<<."
        echo "File name pattern >>${FILE_NAME_PATTERN}<<."
    fi

    find "${WORKING_DIRECTORY_PATH}" -iname "${FILE_NAME_PATTERN}" -type f -print0 | while read -d $'\0' FOUND_FILE_PATH;
    do
        if [[ ${LEVEL_OF_VERBOSITY} -gt 1 ]];
        then
            echo "   Found file path >>${FOUND_FILE_PATH}<<."
        fi

        #index always starts with 0
        local INDEX_OF_THE_FILE_NAME_PATTERN=$(expr index "${FOUND_FILE_PATH}" "${FILE_NAME_PATTERN}")
        if [[ ${LEVEL_OF_VERBOSITY} -gt 2 ]];
        then
            echo "   Index >>${INDEX_OF_THE_FILE_NAME_PATTERN}<<."
        fi
        #we just add one
        #local INDEX_OF_THE_FILE_NAME_PATTERN=$((INDEX_OF_THE_FILE_NAME_PATTERN+1))
        #echo "   Index >>${INDEX_OF_THE_FILE_NAME_PATTERN}<<."
        #and now we substract the length of pattern
        #we don't have to add the one
        local INDEX_OF_THE_FILE_NAME_PATTERN=$((INDEX_OF_THE_FILE_NAME_PATTERN+${LENGTH_OF_THE_FILE_NAME_PATTERN}))
        if [[ ${LEVEL_OF_VERBOSITY} -gt 2 ]];
        then
            echo "   Index >>${INDEX_OF_THE_FILE_NAME_PATTERN}<<."
        fi

        local SOURCE_FILE_PATH="${FOUND_FILE_PATH:0:-${INDEX_OF_THE_FILE_NAME_PATTERN}}"

        if [[ -f "${SOURCE_FILE_PATH}" ]];
        then
            local SIZE_OF_CONVERTED_FILE_PATH=$(stat --printf="%s" ${FOUND_FILE_PATH})
            local SIZE_OF_SOURCE_FILE_PATH=$(stat --printf="%s" ${SOURCE_FILE_PATH})

            local SIZE_COMPARED=$(calc ${SIZE_OF_SOURCE_FILE_PATH}/${SIZE_OF_CONVERTED_FILE_PATH})

            if [[ ${SIZE_COMPARED} > ${SIZE_THRESHOLD_LIMIT} ]];
            then
                echo ":: Threshold limit reached!"
                echo "   Source file size >>${SIZE_OF_SOURCE_FILE_PATH}<<."
                echo "   Converted file size >>${SIZE_OF_CONVERTED_FILE_PATH}<<."
                echo "   Size compared >>${SIZE_COMPARED}<<."
                echo "   Source file path >>${SOURCE_FILE_PATH}<<."
                echo "   Converted file path >>${FOUND_FILE_PATH}<<."
            else
                if [[ ${LEVEL_OF_VERBOSITY} -gt 0 ]];
                then
                    echo ":: Removing file >>${SOURCE_FILE_PATH}<<."
                fi

                if [[ ${IS_DRY_RUN} -eq 0 ]];
                then
                    rm "${SOURCE_FILE_PATH}"
                fi
            fi
        else
            if [[ ${LEVEL_OF_VERBOSITY} -gt 1 ]];
            then
                echo ":: Is not a file >>${SOURCE_FILE_PATH}<<."
            fi
        fi
    done;
}

####
# [@param int $NUMBER_OF_DIRECTORIES_TO_OUTPUT=20]
# [@param int $MAX_DEPTH=1]
####
# @see https://opensource.com/article/18/9/shell-dotfile
# @since 2018-09-06
# @author stev leibelt
function net_bazzline_list_biggest_directories ()
{
    local NUMBER_OF_DIRECTORIES_TO_OUTPUT=${1:-20}
    local MAX_DEPTH=${2:-1}

    du -h --max-depth=${MAX_DEPTH} 2> /dev/null | sort -n -r | head -n${NUMBER_OF_DIRECTORIES_TO_OUTPUT}
}
