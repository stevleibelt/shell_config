#!/bin/bash
####
# @author stev leibelt <artodeto@bazzline.net>
# @since 2013-04-24
####

####
# https://www.gnu.org/software/bash/manual/bash.html
####

#####
# If one value is given, mkdir -p plus cd is called.
# If multiple values are given. mkdir is called.
#
# @param string $# - string name of directory you want to create
#
# @author stev leibelt
# @since 2013-01-05
####
function net_bazzline_mkdir ()
{
    #check if at least one argument is supplied
    if [[ $# -eq 0 ]]; then
        echo "No arguments supplied"
        return 1
    fi

    #if one argument is supplied, create dir and
    # change to it
    if [[ $# -eq 1 ]]; then
        mkdir -p "$1" 
        cd "$1"
        return 0
    fi

    #if more then one argument is supplied
    # execute default mkdir
    if [[ $# -gt 1 ]]; then
        mkdir $@
        return 0
    fi
}

####
# create a directory with a prefix of current date (Ymd)
#
# @param string $1 - directory name you want to create
#
# @author stev leibelt
# @since 2013-03-08
####
function net_bazzline_mkdirPrefixCurrentDate ()
{
    if [[ $# -eq 1 ]]; then
        directoryName=`eval date +%y%m%d`"_$1"

        net_bazzline_mkdir "$directoryName"
    else
        echo 'Should be called with exactly one parameter'
    fi
}

####
# create a file with a prefix of current date (Ymd)
#
# @param string $1 - file name you want to create
#
# @author stev leibelt
# @since 2014-09-20
####
function net_bazzline_touchPrefixCurrentDate ()
{
    if [[ $# -eq 1 ]]; then
        directoryName=`eval date +%y%m%d`"_$1"

        touch "$directoryName"
    else
        echo 'Should be called with exactly one parameter'
    fi
}

#####
# You can change $i levels by using cd $i
#
# @param mixed $1 - [optional] path where you want do change
#                       or number of directories you want to
#                       change upwards - default is $HOME
#
# @author stev leibelt
# @since 2013-01-30
####
function net_bazzline_cd ()
{
    #is numeric value?
    if [[ $# -eq 0 ]]; then 
        cd "$HOME"
    elif [[ `expr $1 + 1 2> /dev/null` ]]; then
        for (( i=1; i <= $1; i++))
        do
            cd ..
        done
    else
        cd "$1"
    fi
}

#####
# Combines ps aux and grep
#
# @param string $1 - pattern your are searching for
#
# @author stev leibelt
# @since 2013-01-30
####
function net_bazzline_psgrep ()
{
    if [[ $# -eq 1 ]]; then
        ps aux | grep "$1"
    fi
}

####
# calls svn log with limit and pipes content into a grep
#
# @param string $1 - pattern / what you search for
# @param integer $2 - svn log limit
#
# @author stev leibelt
# @since 2014-11-11
####
function net_bazzline_svn_log_grep ()
{
    if [[ $# -eq 1 ]]; then
        svn log --limit 1000 | grep -B2 "$1"
    elif [[ $# -eq 2 ]]; then
        svn log --limit "$2" | grep -B2 "$1"
    else
        echo 'invalid number of arguments supplied.'
        echo 'Usage:'
        echo 'net_bazzline_svn_log_grep <pattern:string> [<limit:int>]'
    fi
}

#####
# Calls svn diff for two repositories.
# Call $repositoryUrlOne $repositoryUrlTwo $filePath
# Use --summarize as default, so only filenames are shown
#
# @param string $1 - first repository
# @param string $2 - second repository
# @param string $3 - path of file to diff
# [@param string $4 - if set, summarize is disabled]
#
# @author stev leibelt
# @since 2013-01-30
####
function net_bazzline_svn_diff ()
{
    if [[ $# -eq 3 ]]; then
        svn diff --summarize "$1""/""$3" "$2""/""$3"
    elif [[ $# -eq 4 ]]; then
        svn diff "$1""/""$3" "$2""/""$3"
    else
        echo 'No valid arguments supplied'
        echo 'repositoryUrlOne repositoryUrlTwo filePath [disableSummerize]'
    fi
}

####
# creates tar archvie
#
# @param string $1 - archvie name
# @param string $@ - paths
#
# @author stev leibelt
# @since 2013-07-19
####
function net_bazzline_tar_create ()
{
    if [[ $# -lt 2 ]]; then
        echo 'No valid arguments supplied.'
        echo 'archive path1 [pathX]'

        exit 1
    fi

    FILENAME="$1"

    # remove $1
    shift

    tar -cf $FILENAME "$@"
}

####
# lists content of a tar archvie
#
# @param string $1 - archvie name
#
# @author stev leibelt
# @since 2013-07-19
####
function net_bazzline_tar_list ()
{
    if [[ $# -eq 1 ]]; then
        tar -tvf "$1"
    else
        echo 'No valid arguments supplied.'
        echo 'archive'

        exit 1
    fi
}

####
# extract content of a tar archvie
#
# @param string $1 - archvie name
#
# @author stev leibelt
# @since 2013-07-19
####
function net_bazzline_tar_extract ()
{
    if [[ $# -eq 1 ]]; then
        tar -xf "$1"
    else
        echo 'No valid arguments supplied.'
        echo 'archive'

        exit 1
    fi
}

####
# compress given directories into tar.gz
#
# @param string $1 - compressed tar.gz file name
# @param string $@ - [all following] files for compressed file
#
# @author stev leibelt
# @since 2013-02-02
####
function net_bazzline_compress ()
{
    if [[ $# -lt 1 ]]; then
        echo 'No valid arguments supplied.'

        exit 1
    fi

    FILENAME_TAR="$1".tar.gz

    if [[ $# -gt 1 ]]; then
        shift
    fi

    tar --ignore-failed-read -zcf "$FILENAME_TAR" "$@"
}

####
# compress given directories into tar.gz
#
# @param string $1 - path to compressed tar.gz file
# @param string $2 - [optional] output path - default is name of the file
#
# @author stev leibelt
# @since 2013-02-02
####
function net_bazzline_decompress ()
{
    if [[ $# -lt 1 ]]; then
        echo 'No valid arguments supplied.'
        echo 'Try net_bazzline_decompress $nameOfCompressedFile [$pathToDecompress]'

        exit 1
    fi

    if [[ $# -eq 1 ]]; then
        tar -zxf "$1"
    else
        tar -zxf "$1" -C "$2"
    fi
}

####
# burns given iso file
#
# @param string $1 - path to iso file
# @param string $2 - [optional] device to burn - default is cdrom
#
# @author stev leibelt
# @since 2013-02-12
####
function net_bazzline_burn ()
{
    if [[ $# -lt 1 ]]; then
        echo 'No valid argument supplied.'
        echo 'Try net_bazzline_burn $isoFile [$opticalDevice]'

        exit 1
    fi

    if [[ $# -eq 1 ]]; then
        sudo wodim -v dev=/dev/cdrom "$1"
    else
        sudo wodim -v dev=/dev/"$2" "$1"
    fi
}

####
# calles find with given param and type f
#
# @param string $1 - pattern you are searching for
# @param [string $2] - path to serching in
# @param [bool $3] - do not ignore dot files
#
# dot exclusion taken from: https://www.linuxquestions.org/questions/linux-general-1/find-and-excluding-all-hidden-directories-910578/
#
# @author stev leibelt
# @since 2013-03-08
####
function net_bazzline_find_file ()
{
    if [[ $# -eq 1 ]]; then
        find . -iname "$1" -not -path "*/.*/*" -not -name ".*" -type f 2>/dev/null
    elif [[ $# -eq 2 ]]; then
        find "$2"  -iname "$1" -not -path "*/.*/*" -not -name ".*" -type f 2>/dev/null
    elif [[ $# -eq 3 ]]; then
        find "$2" -iname "$1" -type f 2>/dev/null
    else
        echo 'No valid argument supplied.'
        return 1
    fi
}

####
# calles find with given param and type d
#
# @param string $1 - pattern your are searching for
# @param [string $2] - path to serching in
#
# @author stev leibelt
# @since 2013-03-08
####
function net_bazzline_find_directory ()
{
    if [[ $# -eq 1 ]]; then
        find . -iname "$1" -type d 2>/dev/null
    elif [[ $# -eq 2 ]]; then
        find "$2" -iname "$1" -type d 2>/dev/null
    else
        echo 'No valid argument supplied.'
        return 1
    fi
}

####
# refresh given interface
#
# @param string $1 - [optional] interface - default eth0
#
# @todo implement --verbose --list-interfaces
# @author stev leibelt
# @since 2013-04-30
####
function net_bazzline_refresh_interface ()
{
    LENGTH=${#NET_BAZZLINE_INTERFACES[@]}

    if [[ $LENGTH -eq 0 ]]; then
        echo 'Environment variable NET_BAZZLINE_INTERFACES not defined or empty'
        return 1
    fi

    if [[ $# -eq 0 ]]; then
        INTERFACE=${NET_BAZZLINE_INTERFACES[0]}
    else
        for NET_BAZZLINE_INTERFACE in "${NET_BAZZLINE_INTERFACES[@]}"
        do
            if [[ "$1" -eq $NET_BAZZLINE_INTERFACE ]]; then
                INTERFACE=$1
            fi
        done

        #set default if none is found
        INTERFACE=${INTERFACE:-$NET_BAZZLINE_INTERFACES[0]}
    fi

    sudo ip link set $INTERFACE down
    sudo ip link set $INTERFACE up
    sudo dhcpcd $INTERFACE
}

####
# Show differences between two directories
#
# @param string $1 - path to first directory
# @param string $2 - path to second directory
# 
# @author stev leibelt <artodeto@arcor.de>
# @since 2013-05-21
function net_bazzline_diff_directory ()
{
    if [[ $# -eq 2 ]]; then
        diff -qr "$1" "$2" | sort
    else
        echo 'No valid argument supplied.'
        echo 'Try command directory1 directory2'
        return 1
    fi
}

####
# Takes a screenshot
# https://wiki.archlinux.org/index.php/Screenshot
#
# @param string $1 - [optional] filename with extension
#
# @author stev leiblt <artodeto@arcor.de>
# @since 2013-05-25
####
function net_bazzline_screenshot ()
{
    if [[ $# -eq 0 ]]; then
        FILENAME='screenshot.jpg'
    else
        FILENAME="$1"
    fi

    import -window root $FILENAME
}

####
# Creates code coverage report by using phpunit
#
# @param string $1 - [optional] directory where to store report
#                    default is "./report"
#
# @author stev leiblt <artodeto@arcor.de>
# @since 2013-06-13
####
function net_bazzline_phpunit_codecoverage ()
{
    if [[ $# -eq 1 ]]; then
        DIRECTORY_FOR_REPORT="$1"
    else
        DIRECTORY_FOR_REPORT='./report'
    fi

    phpunit --coverage-html $DIRECTORY_FOR_REPORT
}

####
# Rsync with default values
#
# @author stev leibelt <artodeto@arcor.de>
# @since 2013-12-21
####
function net_bazzline_sync_to ()
{
    if [[ $# -eq 0 ]]; then
        echo 'invalid number of variables provided'
        echo 'command [source one] [source ...] target'
        return 1
    elif [[ $# -eq 1 ]]; then
        rsync -aq . "$1"
    else
        rsync -aq $@
    fi
}

####
# Uses rsync with ssh to copy data from remote to local host
#
# @param string $1 - remote user
# @param string $2 - remote host
# @param string $3 - source path on remote host
# @param string $4 - destination path on local host
# [@param string $5 - ssh key]
#
# @author stev leibelt <artodeto@arcor.de>
# @since 2013-07-05
####
function net_bazzline_sync_from_host ()
{
    if [[ $# -eq 4 ]]; then
        USER="$1"
        HOST="$2"
        SOURCE="$3"
        DESTINATION="$4"

        rsync -aqz -e ssh $USER@$HOST:$SOURCE $DESTINATION
    elif [[ $# -eq 5 ]]; then
        USER="$1"
        HOST="$2"
        SOURCE="$3"
        DESTINATION="$4"
        KEY="$5"

        rsync -aqz -e ssh -i $KEY $USER@$HOST:$SOURCE $DESTINATION
    else
        echo 'invalid number of variables provided'
        echo 'command user host source destination'
        return 1
    fi
}

####
# Uses rsync with ssh to copy data from local to remote host
#
# @param string $1 - remote user
# @param string $2 - remote host
# @param string $3 - source path on local host
# @param string $4 - destination path on remote host
# [@param string $5 - ssh key]
#
# @author stev leibelt <artodeto@arcor.de>
# @since 2013-07-05
####
function net_bazzline_sync_to_host ()
{
    if [[ $# -eq 4 ]]; then
        USER="$1"
        HOST="$2"
        SOURCE="$3"
        DESTINATION="$4"

        rsync -avz -e ssh $SOURCE $USER@$HOST:$DESTINATION
    elif [[ $# -eq 5 ]]; then
        USER="$1"
        HOST="$2"
        SOURCE="$3"
        DESTINATION="$4"
        KEY="$5"

        rsync -aqz -e ssh -i $KEY $SOURCE $USER@$HOST:$DESTINATION
    else
        echo 'invalid number of variables provided'
        echo 'command user host source destination'
        return 1
    fi
}

####
# Converts all mp3s to wav in current directory
# taken from: https://wiki.archlinux.org/index.php/CD_Burning#Burning_an_audio_CD
#
# @author stev leibelt <artodeto@arcor.de>
# @since 2013-07-17
####
function net_bazzline_convert_mp3_to_wav ()
{
    for i in *.mp3; 
    do 
        lame --decode "$i" "$(basename "$i" .mp3)".wav;
    done
}

####
# Converts all m4as to wav in current directory
# taken from: http://www.togaware.com/linux/survivor/Convert_m4a.html
#
# @author stev leibelt <artodeto@arcor.de>
# @since 2013-07-17
####
function net_bazzline_convert_m4a_to_wav ()
{
    for i in *.m4a;
    do
        faad -f 1 -o "$i.wav" "$i"
    done
}

####
# Converts all wavs to mp3s in current directory
# taken from: https://www.linuxquestions.org/questions/linux-general-1/converting-m4a-to-mp3-170553/
#
# @author stev leibelt <artodeto@arcor.de>
# @since 2013-07-17
####
function net_bazzline_convert_wav_to_mp3 ()
{
    for i in *.wav;
    do
        lame --replaygain-accurate -v -h -b 192 "$i" "$i.mp3";
    done
}

####
# Replaces a string in all files in given path and below
# taken from: http://www.cyberciti.biz/faq/unix-linux-replace-string-words-in-many-files/
# taken from: http://stackoverflow.com/questions/4437901/find-and-replace-string-in-a-file
# taken from: http://stackoverflow.com/questions/7450324/how-do-i-replace-a-string-with-another-string-in-all-files-below-my-current-dir
#
# @author stev leibelt <artodeto@arcor.de>
# @since 2013-7-30
####
function net_bazzline_replace_string_in_files ()
{
    if [[ $# -lt 3 ]]; then
        echo 'invalid number of arguments provided'
        echo 'command search replace fileextension [path]'
        return 1
    fi

    SEARCH="$1"
    REPLACE="$2"
    FILE_EXTENSION="$3"

    if [[ $# -eq 4 ]]; then
        PATH="$4"
    else
        PATH="."
    fi

    find "$PATH" -name "*.$FILE_EXTENSION" -type f -exec sed -i 's/'"$SEARCH"'/'"$REPLACE"'/g' {} \;
}

####
# Find all pacnew files
#
# @author stev leibelt <artodeto@arcor.de>
# @since 2013-08.14
####
function net_bazzline_arch_linux_locate_pacnew_files ()
{
    FILENAME='pacnew.'$(date + '%y%m%d')

    sudo find / -iname '*.pacnew' 1> $FILENAME 2>/dev/null
}

####
# Starts php's built in webserver
#
# [@param string $1 - directory that should be used as target, default is public]
# [@param int $2 - port the webserver should listen on, default is 80]
#
# @author stev leibelt <artodeto@arcor.de>
# @since 2013-08-21
####
function net_bazzline_php_start_internal_webserver ()
{
    if [[ $# -eq 2 ]]; then
        DIRECTORY="$1";
        PORT="$2";
    elif [[ $# -eq 1 ]]; then
        DIRECTORY="$1";
        PORT=80;
    else
        DIRECTORY="public";
        PORT=80;
    fi

    sudo php -S 0.0.0.0:"$PORT" -t "$DIRECTORY"
}

####
# Uses grep to prevent using ack-grep on different machines
# Influenced by: http://developmentality.wordpress.com/2010/12/28/ack-better-than-grep/
#
# @param string pattern
# [@param] string search path
# [@param] string directory path to exclude - and following parameters
#
# @author stev leibelt <artodeto@arcor.de>
# @since 2013-10-02
####
function net_bazzline_bash_grep ()
{
    grep -rI –color –exclude-dir=\.bzr –exclude-dir=\.git –exclude-dir=\.hg –exclude-dir=\.svn –exclude-dir=build –exclude-dir=dist –exclude=tags $*
}

####
# Converts images in directory with given size
#
# @param int size
#
# @author stev leibelt <artodeto@arcor.de>
# @since 2013-10-02
####
function net_bazzline_image_batch_convert ()
{
    DIRECTORY="resized_"$1;

    mkdir $DIRECTORY
    for f in *.[jJ][pP][gG]
    do convert $f -verbose -geometry $1x$1 -quality 98% -comment "proud made with linux" $DIRECTORY/$f
    done
}

####
# Converts images in directory with size of 1920
#
# @author stev leibelt <artodeto@arcor.de>
# @since 2013-10-02
####
function net_bazzline_image_batch_convert_1920 ()
{
    net_bazzline_image_batch_convert 1920
}

####
# Converts images in directory with size of 1024
#
# @author stev leibelt <artodeto@bazzline.net>
# @since 2014-03-16
####
function net_bazzline_image_batch_convert_1024 ()
{
    net_bazzline_image_batch_convert 1024
}


####
# Converts images in directory with size of 640
#
# @author stev leibelt <artodeto@bazzline.net>
# @since 2014-08-03
####
function net_bazzline_image_batch_convert_640 ()
{
    net_bazzline_image_batch_convert 640
}
####
# Renames all existing directory content to lower case
#
# @author stev leibelt <artodeto@arcor.de>
# @since 2013-11-21
####
function net_bazzline_filename_to_lower_batch_rename ()
{
    #rename 'y/A-Z/a-z/' *
    find . -type f -execdir sh -c 'mv "'{}'" "$(echo '{}'|tr '[:upper:]' '[:lower:]')"' \;
}

####
# get filename from filepath
# based: http://stackoverflow.com/questions/965053/extract-filename-and-extension-in-bash
# take also a look to:  https://www.gnu.org/software/bash/manual/html_node/Shell-Parameter-Expansion.html
#                       http://stackoverflow.com/questions/3236871/how-to-return-a-string-value-from-a-bash-function
#
# use it like echo $(net_bazzline_get_filename_from_filepath my/path/to/a/file.extension)
#
# @author stev leibelt <artodeto@arcor.de>
# @since 2013-11-30
####
function net_bazzline_get_filename_from_filepath ()
{
    if [[ $# -eq 1 ]]; then
        FILENAME=$(basename "$1")
        echo $FILENAME

        return 0
    else
        echo "invalid number of arguments supplied"
        echo "filepath"

        return 1
    fi
}

####
# get name without extension from filename
# based: http://stackoverflow.com/questions/965053/extract-filename-and-extension-in-bash
# take also a look to: https://www.gnu.org/software/bash/manual/html_node/Shell-Parameter-Expansion.html
#
# use it like echo $(net_bazzline_get_name_from_filename name.extension)
#
# @author stev leibelt <artodeto@arcor.de>
# @since 2013-11-30
####
function net_bazzline_get_name_from_filename ()
{
    if [[ $# -eq 1 ]]; then
        NAME="${1%%.*}"
        echo $NAME

        return 0
    else
        echo "invalid number of arguments supplied"
        echo "filename"

        return 1
    fi
}

####
# get extension from filename
# based: http://stackoverflow.com/questions/965053/extract-filename-and-extension-in-bash
# take also a look to:  https://www.gnu.org/software/bash/manual/html_node/Shell-Parameter-Expansion.html
#                       http://stackoverflow.com/questions/11426590/bash-bad-substitution
#
# use it like echo $(net_bazzline_get_extension_from_filename name.extension)
#
# @author stev leibelt <artodeto@arcor.de>
# @since 2013-11-30
####
function net_bazzline_get_extension_from_filename ()
{
    if [[ $# -eq 1 ]]; then
        EXTENSION="${1#*.}"
        echo $EXTENSION

        return 0
    else
        echo "invalid number of arguments supplied"
        echo "filename"

        return 1
    fi
}

####
# copies content of mkv container to avi container
#
# take a look on:   http://www.cyberciti.biz/faq/bash-shell-script-function-examples/
#
# @author stev leibelt <artodeto@arcor.de>
# @since 2013-11-30
####
function net_bazzline_convert_mkv_to_avi ()
{
    if [[ $# -eq 1 ]]; then
        #export -f net_bazzline_get_name_from_filename
        nameFromFilename=net_bazzline_get_name_from_filename
        INPUT_FILE="$1";
        OUTPUT_FILE=$($nameFromFilename $INPUT_FILE)
        #OUTPUT_FILE=$(net_bazzline_get_name_from_filename $INPUT_FILE)
        OUTPUT_FILE=$OUTPUT_FILE".avi"
    elif [[ $# -eq 2 ]]; then
        INPUT_FILE="$1";
        OUTPUT_FILE="$2";
    else
        echo "invalid number of arguments supplied"
        echo "inputfile [outputfile]"
        return 1
    fi

    ffmpeg -i "$INPUT_FILE" -c:v copy -c:a copy "$OUTPUT_FILE"
}

####
# lists all available process listening on given port
#
# @param integer $1 - port number
#
# @author stev leibelt <artodeto@bazzline.net>
# @since 2014-04-07
####
function net_bazzline_what_is_listening_on_that_port()
{
    if [[ $# -eq 1 ]]; then
        netstat -tulpn | grep --color :$1
    else
        echo "invalid number of arguments supplied"
        echo "portnumber"
        return 1
    fi
}

####
# adds "." to the beginning of the directory or file name
# 
# @param string $1 - file system object identifier
#
# @author stev leibelt <artodeto@bazzline.net>
# @since 2014-07-31
####
function net_bazzline_hide_file_system_object()
{
    if [[ $# -eq 1 ]]; then
# @todo validate if identifier is file or directory and if first character is not "."
# @todo use net_bazzline_stringStartsWith
        mv "$1" ."$1"
    else
        echo "Usage: net_bazzline_unhide_directory <directory_name>"
        return 1
    fi
}

####
# adds "." to the beginning of the directory or file name
#
# @author stev leibelt <artodeto@bazzline.net>
# @since 2014-07-31
####
function net_bazzline_unhide_file_system_object()
{
    if [[ $# -eq 1 ]]; then
        IDENTIFIER="$1";
# @todo validate if identifier is file or directory and if first character is "."
# @todo use net_bazzline_stringStartsWith
        #if [[ net_bazzline_stringStartsWith $IDENTIFIER "." ]]; then
            mv $IDENTIFIER ${IDENTIFIER:1};
            return 0
        #else
            #echo $IDENTIFIER" has to start with ."
            #return 1
    else
        echo "Usage: net_bazzline_unhide_directory <directory_name>"
        return 1
    fi
}

####
# validates if string starts with given string or not
# 
# @param string $1 - string
# @param string $2 - needle
# 
# @author stev leibelt <artodeto@bazzline.net>
# @since 2014-07-31
####
function net_bazzline_stringStartsWith ()
{
    if [[ $# -eq 2 ]]; then
        STRING="$1"
        SUB_STRING="$2"
        LENGTH_OF_SUB_STRING=${#SUB_STRING}
        STRING_WITH_SUB_STRING_ONLY=${STRING:0:$LENGTH_OF_SUB_STRING}

        if [[ $STRING_WITH_SUB_STRING_ONLY = $SUB_STRING ]]; then
            return 0
        else
            return 1
        fi
    else
        echo "Usage: net_bazzline_stringStartsWitch <string> <needle>"
        return 1
    fi
}

####
# list available interfaces
# 
# @author stev leibelt <artodeto@bazzline.net>
# @since 2014-10-28
####
function net_bazzline_list_interfaces ()
{
    ip a | grep ':\ '
}

function net_bazzline_test ()
{
STRING=".md"
SUB_STRING="."

# not working
if [[ $(net_bazzline_stringStartsWith $STRING $SUB_STRING) ]]; then
    echo 'stats with'
else
    echo 'stats with not'
fi

STARTS_WITH=$(net_bazzline_stringStartsWith $STRING $SUB_STRING)
echo "$STARTS_WITH"

if [[ $STARTS_WITH -eq 0 ]]; then
    echo 'starts with'
else
    echo 'starts not with'
fi
}
