#!/bin/bash
####
# @author stev leibelt <artodeto@bazzline.net>
# @since 2013-04-24
# @see https://www.gnu.org/software/bash/manual/bash.html
# @todo 
#   prefix all local variables with "LOCAL_"
#   move fitting code into c++ code
####

#b

####
# Rsync with default backup values
#
# @author stev leibelt <artodeto@bazzline.net>
# @since 2015-04-07
####
function net_bazzline_backup_to ()
{
    if [[ $# -eq 0 ]]; then
        echo 'invalid number of variables provided'
        echo 'command [source one] [source ...] target'
        return 1
    elif [[ $# -eq 1 ]]; then
        net_bazzline_rsync . "$1"
    else
        net_bazzline_rsync $@
    fi
}

####
# Uses grep to prevent using ack-grep on different machines
# Influenced by: http://developmentality.wordpress.com/2010/12/28/ack-better-than-grep/
#
# @param string pattern
# [@param] string search path
# [@param] string directory path to exclude - and following parameters
#
# @author stev leibelt <artodeto@bazzline.net>
# @since 2013-10-02
####
function net_bazzline_bash_grep ()
{
    grep -rI –-color=auto –-exclude-dir=\.bzr –-exclude-dir=\.git –-exclude-dir=\.hg –-exclude-dir=\.svn –-exclude-dir=build –-exclude-dir=dist –-exclude=tags $*
}

####
# Converts images in directory with given size
#
# @param int size
# [@param] string name for the directory
#
# @author stev leibelt <artodeto@bazzline.net>
# @since 2013-10-02
####
function net_bazzline_image_batch_convert ()
{
    if [[ $# -eq 2 ]]; then
        DIRECTORY="$2";
    else
        DIRECTORY="resized_"$1;
    fi

    #@todo implement check if directory exists
    mkdir $DIRECTORY
    for FILE in *.[jJ][pP][gG]; do
        convert $FILE -verbose -geometry $1x$1 -quality 98% -comment "proud made with linux" $DIRECTORY/$FILE
    done;
}

####
# Converts images in directory with size of 1024
#
# [@param] string name for the directory
#
# @author stev leibelt <artodeto@bazzline.net>
# @since 2014-03-16
####
function net_bazzline_image_batch_convert_1024 ()
{
    if [[ $# -eq 1 ]]; then
        net_bazzline_image_batch_convert 1024 "$1"
    else
        net_bazzline_image_batch_convert 1024
    fi
}

####
# Converts images in directory with size of 1920
#
# [@param] string name for the directory
#
# @author stev leibelt <artodeto@bazzline.net>
# @since 2013-10-02
####
function net_bazzline_image_batch_convert_1920 ()
{
    if [[ $# -eq 1 ]]; then
        net_bazzline_image_batch_convert 1920 "$1"
    else
        net_bazzline_image_batch_convert 1920
    fi
}

####
# Converts images in directory with size of 640
#
# [@param] string name for the directory
#
# @author stev leibelt <artodeto@bazzline.net>
# @since 2014-08-03
####
function net_bazzline_image_batch_convert_640 ()
{
    if [[ $# -eq 1 ]]; then
        net_bazzline_image_batch_convert 640 "$1"
    else
        net_bazzline_image_batch_convert 640
    fi
}

####
# burns given iso file
#
# @param string $1 - path to iso file
# @param string $2 - [optional] device to burn - default is cdrom
#
# @author stev leibelt
# @since 2013-02-12
####
function net_bazzline_burn ()
{
    if [[ $# -lt 1 ]]; then
        echo 'No valid argument supplied.'
        echo 'Try net_bazzline_burn $isoFile [$opticalDevice]'

        exit 1
    fi

    if [[ $# -eq 1 ]]; then
        sudo wodim -v dev=/dev/cdrom "$1"
    else
        sudo wodim -v dev=/dev/"$2" "$1"
    fi
}

#c

#####
# You can change $i levels by using cd $i
#
# @param mixed $1 - [optional] path where you want do change
#                       or number of directories you want to
#                       change upwards - default is $HOME
#
# @author stev leibelt
# @since 2013-01-30
####
function net_bazzline_cd ()
{
    #is numeric value?
    if [[ $# -eq 0 ]]; then 
        cd "$HOME"
    elif [[ `expr $1 + 1 2> /dev/null` ]]; then
        for (( i=1; i <= $1; i++))
        do
            cd ..
        done
    else
        \cd "$1"
    fi
}

####
# compress given directories into tar.gz
#
# @param string $1 - compressed tar.gz file name
# @param string $@ - [all following] files for compressed file
#
# @author stev leibelt
# @since 2013-02-02
####
function net_bazzline_compress ()
{
    if [[ $# -lt 1 ]]; then
        echo 'No valid arguments supplied.'

        exit 1
    fi

    FILENAME_TAR="$1".tar.gz

    if [[ $# -gt 1 ]]; then
        shift
    fi

    tar --ignore-failed-read -zcf "$FILENAME_TAR" "$@"
}

####
# @author stev leibelt <artodeto@bazzline.net>
# @since 2015-01-19
# @see
#   https://answers.yahoo.com/question/index?qid=20080901083928AA22hSM
#   http://askubuntu.com/questions/113188/character-encoding-problem-with-filenames-find-broken-filenames
####
function net_bazzline_convert_file_names_to_utf_8 ()
{
    if [[ $# -lt 1 ]]; then
        echo 'usage: <command> <path> [dry-run|d]'
        return 1
    else
        DIRECTORY_PATH="$1"

        if [[ $# -eq 2 ]]; then
            case "$2" in 
                "d")
                    DRY_RUN=1;;
                "dry-run")
                    DRY_RUN=1;;
                *)
                    DRY_RUN=0
            esac
        fi

        for name in `find $DIRECTORY_PATH -depth `; do 
            NEW_NAME=`echo $NAME | iconv -f ISO-8859-1 -t UTF-8` 

            if [[ $DRY_RUN -eq 1 ]]; then
                `echo $NAME | iconv -f UTF-8 -t ISO-8859-1` 
            fi

            if [[ "$NEW_NAME" != "$NAME" ]]; then 
                if [[ $DRY_RUN -eq 1 ]]; then
                    echo "$NAME => $NEW_NAME" 
                else
                    mv "$NAME" "$NEW_NAME" 
                fi
            fi 
        done 
    fi
}

####
# Converts all m4as to wav in current directory
# taken from: http://www.togaware.com/linux/survivor/Convert_m4a.html
#
# @author stev leibelt <artodeto@bazzline.net>
# @since 2013-07-17
####
function net_bazzline_convert_m4a_to_wav ()
{
    for i in *.m4a;
    do
        faad -f 1 -o "$i.wav" "$i"
    done
}

####
# copies content of mkv container to avi container
#
# take a look on:   http://www.cyberciti.biz/faq/bash-shell-script-function-examples/
#
# @author stev leibelt <artodeto@bazzline.net>
# @since 2013-11-30
####
function net_bazzline_convert_mkv_to_avi ()
{
    if [[ $# -eq 1 ]]; then
        #export -f net_bazzline_get_name_from_filename
        nameFromFilename=net_bazzline_get_name_from_filename
        INPUT_FILE="$1";
        OUTPUT_FILE=$($nameFromFilename $INPUT_FILE)
        #OUTPUT_FILE=$(net_bazzline_get_name_from_filename $INPUT_FILE)
        OUTPUT_FILE=$OUTPUT_FILE".avi"
    elif [[ $# -eq 2 ]]; then
        INPUT_FILE="$1";
        OUTPUT_FILE="$2";
    else
        echo "invalid number of arguments supplied"
        echo "inputfile [outputfile]"
        return 1
    fi

    ffmpeg -i "$INPUT_FILE" -c:v copy -c:a copy "$OUTPUT_FILE"
}

####
# Converts all mp3s to wav in current directory
# taken from: https://wiki.archlinux.org/index.php/CD_Burning#Burning_an_audio_CD
#
# @author stev leibelt <artodeto@bazzline.net>
# @since 2013-07-17
####
function net_bazzline_convert_mp3_to_wav ()
{
    for i in *.mp3; 
    do 
        lame --decode "$i" "$(basename "$i" .mp3)".wav;
    done
}

####
# @param string $1 - path to the source file
# @param string $2 - path to the destination file
# [@param string $3 - screen size, default is 1024x768]
####
function net_bazzline_convert_video_to_screen_size ()
{
    if [[ $# -lt 2 ]]; then
        echo "invalid number of arguments supplied"
        echo "<path to source file> <path to destination file> [<screen size>]"
        return 1
    else
        if [[ $# -gt 2 ]]; then
            LOCAL_SCREEN_SIZE="$3"
        else
            LOCAL_SCREEN_SIZE="1024x768"
        fi

        LOCAL_PATH_TO_DESTINATION_FILE="$2"
        LOCAL_PATH_TO_SOURCE_FILE="$1"
    fi

    ffmpeg -i "$LOCAL_PATH_TO_SOURCE_FILE" -acodec copy -scodec copy -s "$LOCAL_SCREEN_SIZE" -vcodec libx264 -pass 1 "$LOCAL_PATH_TO_DESTINATION_FILE"
}

####
# Converts all wavs to mp3s in current directory
# taken from: https://www.linuxquestions.org/questions/linux-general-1/converting-m4a-to-mp3-170553/
#
# @author stev leibelt <artodeto@bazzline.net>
# @since 2013-07-17
####
function net_bazzline_convert_wav_to_mp3 ()
{
    for i in *.wav;
    do
        lame --replaygain-accurate -v -h -b 192 "$i" "$i.mp3";
    done
}

####
# [@param string $1 - path to search in]
# [@param string $2 - name/pattern to search for]
#
# @author stev leibelt
# @since 2016-04-10
####
function net_bazzline_count_number_of_items_in_path()
{
    if [[ $# -gt 0 ]]
    then
        LOCAL_PATH="$1"
    else
        LOCAL_PATH="."
    fi

    if [[ $# -gt 1 ]]
    then
        LOCAL_ITEM_NAME="$2"
        LOCAL_NUMBER_OF_ENTRIES_FOR_POSSIBLE_ITEM_NAME=$(find $LOCAL_PATH -maxdepth 1 -not -name ".*" -name "$LOCAL_ITEM_NAME" | wc -l)
    else
        LOCAL_NUMBER_OF_ENTRIES_FOR_POSSIBLE_ITEM_NAME=$(find $LOCAL_PATH -maxdepth 1 -not -name ".*" | wc -l)
    fi

    return $LOCAL_NUMBER_OF_ENTRIES_FOR_POSSIBLE_ITEM_NAME
}

####
# @param string <path to create>
####
function net_bazzline_create_path_or_return_error_if_path_exists_already()
{
    if [[ $# -lt 1 ]]; then
        echo "invalid number of arguments"
        echo "    net_bazzline_create_path_or_return_error_if_path_exists_already <path to create>";
        return 1
    fi

    LOCAL_PATH_TO_CREATE="$1"

    if [[ -d "$LOCAL_PATH_TO_CREATE" ]]; then
        echo "path exist already: $LOCAL_PATH_TO_CREATE"
        return 1
    else
        mkdir -p "$LOCAL_PATH_TO_CREATE"
    fi
}

####
# @param string <name of the zfs pool>
# [@param string <name of the snapshot>, default is current date
####
function net_bazzline_create_zfs_snapshot()
{
    if [[ $# -lt 1 ]]; then
        echo 'invalid number of arguments'
        echo '    net_bazzline_create_zfs_snapshot <name of the zfs pool> [<name of the snapshot>]'
        return 1
    fi

    NAME_OF_THE_POOL="$1"

    if [[ $# -gt 1 ]]; then
        NAME_OF_THE_SNAPSHOT="$2"
    else
        NAME_OF_THE_SNAPSHOT=$(date +'%Y-%m-%d_%H-%M-%S')
    fi

    if sudo zfs snapshot -r $NAME_OF_THE_POOL@$NAME_OF_THE_SNAPSHOT; then
        echo 'snapshot "'$NAME_OF_THE_SNAPSHOT'" created for pool "'$NAME_OF_THE_POOL'"'
    fi

    return $?
}

#d

####
# compress given directories into tar.gz
#
# @param string $1 - path to compressed tar.gz file
# @param string $2 - [optional] output path - default is name of the file
#
# @author stev leibelt
# @since 2013-02-02
####
function net_bazzline_decompress ()
{
    if [[ $# -lt 1 ]]; then
        echo 'No valid arguments supplied.'
        echo 'Try net_bazzline_decompress $nameOfCompressedFile [$pathToDecompress]'

        exit 1
    fi

    if [[ $# -eq 1 ]]; then
        tar -zxf "$1"
    else
        tar -zxf "$1" -C "$2"
    fi
}

####
# @param string <name of zfs pool>
# @param string <name of the snapshot>
####
function net_bazzline_delete_zfs_snapshot()
{
    if [[ $# -lt 2 ]]; then
        echo 'invalid number of arguments'
        echo '    net_bazzline_delete_zfs_snapshot <name of the zfs pool> [<name of the snapshot>]'
        return 1
    fi

    NAME_OF_THE_POOL="$1"
    NAME_OF_THE_SNAPSHOT="$2"

    if sudo zfs destroy -R $NAME_OF_THE_POOL@$NAME_OF_THE_SNAPSHOT; then
        echo 'snapshot "'$NAME_OF_THE_SNAPSHOT'" deleted from pool "'$NAME_OF_THE_POOL'"'
    fi

    return $?
}

####
# Show differences between two directories
#
# @param string $1 - path to first directory
# @param string $2 - path to second directory
# 
# @author stev leibelt <artodeto@bazzline.net>
# @since 2013-05-21
function net_bazzline_diff_directory ()
{
    if [[ $# -eq 2 ]]; then
        diff -qr "$1" "$2" | sort
    else
        echo 'No valid argument supplied.'
        echo 'Try command directory1 directory2'
        return 1
    fi
}

#f

####
# Renames all existing directory content to lower case
#
# @author stev leibelt <artodeto@bazzline.net>
# @since 2013-11-21
####
function net_bazzline_filename_to_lower_batch_rename ()
{
    #rename 'y/A-Z/a-z/' *
    find . -type f -execdir sh -c 'mv "'{}'" "$(echo '{}'|tr '[:upper:]' '[:lower:]')"' \;
}

####
# calles find with given param and type d
#
# @param string $1 - pattern your are searching for
# @param [string $2] - path to serching in
#
# @author stev leibelt
# @since 2013-03-08
####
function net_bazzline_find_directory ()
{
    if [[ $# -eq 1 ]]; then
        find . -iname "$1" -type d 2>/dev/null
    elif [[ $# -eq 2 ]]; then
        find "$2" -iname "$1" -type d 2>/dev/null
    else
        echo 'No valid argument supplied.'
        return 1
    fi
}

####
# calles find with given param and type f
#
# @param string $1 - pattern you are searching for
# @param [string $2] - path to serching in
# @param [bool $3] - do not ignore dot files
#
# dot exclusion taken from: https://www.linuxquestions.org/questions/linux-general-1/find-and-excluding-all-hidden-directories-910578/
#
# @author stev leibelt
# @since 2013-03-08
####
function net_bazzline_find_file ()
{
    if [[ $# -eq 1 ]]; then
        find . -iname "$1" -not -path "*/.*/*" -not -name ".*" -type f 2>/dev/null
    elif [[ $# -eq 2 ]]; then
        find "$2"  -iname "$1" -not -path "*/.*/*" -not -name ".*" -type f 2>/dev/null
    elif [[ $# -eq 3 ]]; then
        find "$2" -iname "$1" -type f 2>/dev/null
    else
        echo 'No valid argument supplied.'
        return 1
    fi
}

#g

####
# get extension from filename
# based: http://stackoverflow.com/questions/965053/extract-filename-and-extension-in-bash
# take also a look to:  https://www.gnu.org/software/bash/manual/html_node/Shell-Parameter-Expansion.html
#                       http://stackoverflow.com/questions/11426590/bash-bad-substitution
#
# use it like echo $(net_bazzline_get_extension_from_filename name.extension)
#
# @author stev leibelt <artodeto@bazzline.net>
# @since 2013-11-30
####
function net_bazzline_get_extension_from_filename ()
{
    if [[ $# -eq 1 ]]; then
        EXTENSION="${1#*.}"
        echo $EXTENSION

        return 0
    else
        echo "invalid number of arguments supplied"
        echo "filename"

        return 1
    fi
}

####
# get filename from filepath
# based: http://stackoverflow.com/questions/965053/extract-filename-and-extension-in-bash
# take also a look to:  https://www.gnu.org/software/bash/manual/html_node/Shell-Parameter-Expansion.html
#                       http://stackoverflow.com/questions/3236871/how-to-return-a-string-value-from-a-bash-function
#
# use it like echo $(net_bazzline_get_filename_from_filepath my/path/to/a/file.extension)
#
# @author stev leibelt <artodeto@bazzline.net>
# @since 2013-11-30
####
function net_bazzline_get_filename_from_filepath ()
{
    if [[ $# -eq 1 ]]; then
        FILENAME=$(basename "$1")
        echo $FILENAME

        return 0
    else
        echo "invalid number of arguments supplied"
        echo "filepath"

        return 1
    fi
}

####
# get name without extension from filename
# based: http://stackoverflow.com/questions/965053/extract-filename-and-extension-in-bash
# take also a look to: https://www.gnu.org/software/bash/manual/html_node/Shell-Parameter-Expansion.html
#
# use it like echo $(net_bazzline_get_name_from_filename name.extension)
#
# @author stev leibelt <artodeto@bazzline.net>
# @since 2013-11-30
####
function net_bazzline_get_name_from_filename ()
{
    if [[ $# -eq 1 ]]; then
        NAME="${1%%.*}"
        echo $NAME

        return 0
    else
        echo "invalid number of arguments supplied"
        echo "filename"

        return 1
    fi
}

####
# @param string $PATH_TO_THE_REPOSITORIES
# @see https://stackoverflow.com/questions/18884992/how-do-i-assign-ls-to-an-array-in-linux-bash
####
function net_bazzline_git_update_all_repositories()
{
    if [[ $# -lt 1 ]]; then
        echo 'invalid number of arguments'
        echo '    net_bazzline_git_update_all_repositories <path to the repositories>'
        return 1
    fi

    PATH_TO_REPOSITORIES=$(realpath $1)
    shopt -s nullglob
    array=("$PATH_TO_REPOSITORIES"/*/)
    shopt -u nullglob

    for entry in ${array[@]}; do
        if [ -d "$entry/.git" ]; then
            echo "$entry"
            cd "$entry"
            git pull
            git fetch --all --prune
            cd "$PATH_TO_REPOSITORIES1"
        else
            net_bazzline_git_update_all_repositories "$entry"
            cd "$PATH_TO_REPOSITORIES1"
        fi  
    done;

    return 0;
}

#h

####
# adds "." to the beginning of the directory or file name
# 
# @param string $1 - file system object identifier
#
# @author stev leibelt <artodeto@bazzline.net>
# @since 2014-07-31
####
function net_bazzline_hide_file_system_object()
{
    if [[ $# -eq 1 ]]; then
# @todo validate if identifier is file or directory and if first character is not "."
# @todo use net_bazzline_string_starts_with
        mv "$1" ."$1"
    else
        echo "Usage: net_bazzline_unhide_directory <directory_name>"
        return 1
    fi
}

#i

####
# checks if directory is empty or not
# @param string $1 - path to the directory
# @return int - 0 if it is empty, 1 if is not empty, 2 on error
####
function net_bazzline_is_directory_empty ()
{
    if [[ $# -lt 1 ]]; then
        echo "Usage: net_bazzline_is_directory_empty <path to the directory>"
        return 2;
    fi

    LOCAL_PATH_TO_THE_DIRECTORY="$1"

    if [[ "$(ls -A $LOCAL_PATH_TO_THE_DIRECTORY)" ]]; then
        LOCAL_DIRECTORY_IS_EMPTY=1;
    else
        LOCAL_DIRECTORY_IS_EMPTY=0;
    fi

    return $LOCAL_DIRECTORY_IS_EMPTY;
}

#l

function net_bazzline_list_empty_directories ()
{
    #@todo
    find . -empty -type d
    #@todo delete_empty_directories
    #find . -empty -delete
}

####
# list groups
# 
# @author stev leibelt <artodeto@bazzline.net>
# @since 2014-11-17
####
function net_bazzline_list_groups ()
{
    getent group | awk -F ':' '{ print $1 }' | sort
}

####
# list available interfaces
# 
# @author stev leibelt <artodeto@bazzline.net>
# @since 2014-10-28
####
function net_bazzline_list_interfaces ()
{
    # also possible
    # ls /sys/class/net
    ip a | grep ':\ '
}

####
# @see http://superuser.com/questions/71163/how-to-find-all-soft-links-symbolic-links-in-current-directory
####
function net_bazzline_list_symbolic_links ()
{
    if [[ $# -gt 1 ]]; then
        echo "usage: <command> <path>"
        return 1
    elif [[ $# -eq 1 ]]; then
        SEARCH_PATH="$1"
    else
        SEARCH_PATH="."
    fi

    find "$SEARCH_PATH" -type l -print0 | xargs -0 ls -ld
}

####
# list system users
# 
# @author stev leibelt <artodeto@bazzline.net>
# @since 2014-11-17
####
function net_bazzline_list_system_users ()
{
    getent passwd | grep -v '/home' | awk -F ':' '{ print $1 }' | sort
}

####
# list users
# 
# @author stev leibelt <artodeto@bazzline.net>
# @since 2014-11-17
####
function net_bazzline_list_users ()
{
    getent passwd | grep '/home' | awk -F ':' '{ print $1 }' | sort
}

####
# [@param string <path to zfs pool>]
####
function net_bazzline_list_zfs_snapshots()
{
    if [[ $# -lt 1 ]]; then
        sudo zfs list -t snapshot
    else
        NAME_OF_THE_POOL="$1"

        sudo zfs list -t snapshot | grep $NAME_OF_THE_POOL
    fi
}

function net_bazzline_load_ssh_keys_in_keychain()
{
    if [[ -f /usr/bin/keychain ]]; then
        if [[ $# -gt 0 ]]; then
            eval $(keychain --eval --quiet --timeout $NET_BAZZLINE_REMEMBER_SSH_PASSWORD_TIMEOUT_IN_MINUTES $@)
        fi
    else
        echo 'keychain is not installed'

        return 1
    fi
}

#m

####
# begin of webcam section
####
function net_bazzline_make_picture_via_webcam()
{
    if [[ -f /usr/bin/fswebcam ]]; then
        LOCAL_CURRENT_DATE_TIME=$(date +'%Y_%m_%d_%H_%M_%S')
        LOCAL_FILE_NAME=$LOCAL_CURRENT_DATE_TIME'.jpg'

        /usr/bin/fswebcam -r 1920x1920 $LOCAL_FILE_NAME
        echo 'created '$LOCAL_FILE_NAME
    else
        echo 'fswebcam is not installed'

        return 1
    fi
}

#####
# If one value is given, mkdir -p plus cd is called.
# If multiple values are given. mkdir is called.
#
# @param string $# - string name of directory you want to create
#
# @author stev leibelt
# @since 2013-01-05
####
function net_bazzline_mkdir ()
{
    #check if at least one argument is supplied
    if [[ $# -eq 0 ]]; then
        echo "No arguments supplied"
        return 1
    fi

    #if one argument is supplied, create dir and
    # change to it
    if [[ $# -eq 1 ]]; then
        mkdir -p "$1" 
        cd "$1"
        return 0
    fi

    #if more then one argument is supplied
    # execute default mkdir
    if [[ $# -gt 1 ]]; then
        mkdir $@
        return 0
    fi
}

####
# create a directory with a prefix of current date (Ymd)
#
# @param string $1 - directory name you want to create
#
# @author stev leibelt
# @since 2013-03-08
####
function net_bazzline_mkdir_prefix_with_current_date ()
{
    if [[ $# -eq 1 ]]; then
        directoryName=`eval date +%y%m%d`"_$1"

        net_bazzline_mkdir "$directoryName"
    else
        echo 'Should be called with exactly one parameter'
    fi
}

####
# @param - source one
# [@param - source two]
# @param destination
####
function net_bazzline_move_in_chunks()
{
    #source [source[...]] destination [--chunk_size=<int>] [--number_of_seconds_to_wait=<int>]
    #begin of input validation
    #@todo do it nicer
    if [[ $# -lt 2 ]];
    then
        echo "invalid number of arguments provided"
        echo "usage: <command> source [source[...]] destination [--chunk_size=<int>] [--number_of_seconds_to_wait=<int>]"
        return 1
    fi

    LOCAL_CHUNK_SIZE=23
    LOCAL_NUMBER_OF_SECONDS_TO_SLEEP_BETWEEN_CHUNKS=7
    #end of input validation

    #begin of moving
    #iterate over source
    #last argument is the target
    #begin foreach souce
    #
    # LOCAL_NUMBER_OF_FILES_IN_SOURCE=$(ls | head -n $LOCAL_CHUNK_SIZE)
    # LOCAL_IF_DIRECTORY_IS_EMPTY=$(net_bazzline_is_directory_empty )
    # @see
    #   http://stackoverflow.com/questions/1853946/getting-the-last-argument-passed-to-a-shell-script
    #   https://duckduckgo.com/?q=bash+get+last+function+argument&ia=qa
    #   http://www.tldp.org/LDP/Bash-Beginners-Guide/html/sect_09_07.html
    #   getopt
    #   http://bahmanm.com/blogs/command-line-options-how-to-parse-in-bash-using-getopt
    #   http://mywiki.wooledge.org/BashFAQ/035#getopts
    #   http://stackoverflow.com/questions/192249/how-do-i-parse-command-line-arguments-in-bash
    # check if $LOCAL_NUMBER_OF_FILES_IN_SOURCE has entries
    #
    #   while $LOCAL_NUMBER_OF_FILES_IN_SOURCE -gt 0
    #       move
    #       sleep
    #       set_number_of_files_
    #end foreach souce
    #end of moving
    SOURCE="$1"                                                                                                         
    DESTINATION="$2"                                                                                                    
    CHUNK_SIZE=7                                                                                                        

    echo "source $SOURCE"                                                                                               
    echo "destination $DESTINATION"                                                                                     

    CURRENT_NUMBER_OF_FILESYSTEM_ITEMS=$(ls -A $SOURCE | wc -l)                                                         

    while [[ $CURRENT_NUMBER_OF_FILESYSTEM_ITEMS -gt 0 ]];                                                              
    do                                                                                                                  
        FILESYSTEM_ITEMS_TO_MOVE=$(ls -A $SOURCE | head -n $CHUNK_SIZE)                                                 

        #for FILESYSTEM_ITEM_TO_MOVE in "${FILESYSTEM_ITEMS_TO_MOVE[@]}";                                               
        for FILESYSTEM_ITEM_TO_MOVE in $(ls -A $SOURCE | head -n $CHUNK_SIZE)                                           
            do                                                                                                              
            #echo "$FILESYSTEM_ITEM_TO_MOVE"                                                                            
            #echo "mv -v \"$SOURCE/$FILESYSTEM_ITEM_TO_MOVE\" \"$DESTINATION/\""                                        
            mv -v "$SOURCE/$FILESYSTEM_ITEM_TO_MOVE" "$DESTINATION/"                                                    
        done                                                                                                            
                                                                        
    sleep $LOCAL_NUMBER_OF_SECONDS_TO_SLEEP_BETWEEN_CHUNKS
done   
}

####
# @param string $zpool
# @param string $uuid
# @param string $crypto name
# [@param string $uuid]
# [@param string $crypto name]
# @author stev leibelt <artodeto@bazzline.net>
# @since 2015-03-15
# @todo implement support for multiple uuids and crypto names, <zpool> <uuid one> <crypto name one> [<uuid two> <crypto name two>[...]]
####
function net_bazzline_mount_luks_zpool ()
{
    if [[ $# -lt 4 ]]; then
        echo 'usage: <command> <zpool> <disk uuid> <crypto name> [<disk uuid> <crypto name>[...]]'
        return 1
    else
        UUID="$2"
        NAME="$3"
        ZPOOL="$1"

        sudo cryptsetup luksOpen /dev/disk/by-uuid/"$UUID" "$NAME"
        sudo zpool import "$ZPOOL"
    fi
}

####
# @param string - mount point
# @param string - name
# @param string - host
# [@param string - path to the identity file]
####
function net_bazzline_mount_sshfs ()
{
    if [[ $# -lt 4 ]]; then
        echo "usage: <command> <mount point> <name> <host> [<path to identity file>]"
        return 1
    else
        MOUNT_POINT="$2"
        NAME="$3"
        HOST="$4"

        if [[ -d "$MOUNT_POINT" ]]; then
            echo 'mount point "'"$MOUNT_POINT"'" exists, remove and retry'
            return 1
        fi

        mkdir -p "$MOUNT_POINT"

        if [[ $# -eq 5 ]]; then
            KEY="$5"

            sshfs -o IdentitiyFile="$KEY" "$NAME"@"$HOST" "$MOUNT_POINT"
        else
            sshfs "$NAME"@"$HOST" "$MOUNT_POINT"
        fi
    fi
}

#o

####
# @param string $# - string name of directory you want to create
#
# @author stev leibelt
# @since 2016-04-07
####
function net_bazzline_organize_directory_content()
{
    #begin of input validation
    if [[ $# -eq 0 ]]; then
        declare -a LOCAL_DIRECTORY_NAMES=("0" "1" "2" "3" "4" "5" "6" "7" "8" "9" "a" "b" "c" "d" "e" "f" "g" "h" "i" "j" "k" "l" "m" "n" "o" "p" "q" "r" "s" "t" "u" "v" "w" "x" "y" "z");
    else
        LOCAL_DIRECTORY_NAMES=( "$@" )
    fi
    #end of input validation

    #begin of declaration
    LOCAL_TEMPORARY_DIRECTORY_NAME="_net_bazzline_organize_directory_content_temporary"
    #end of declaration

    #begin of iteration over all provided arguments
    for LOCAL_DIRECTORY_NAME in "${LOCAL_DIRECTORY_NAMES[@]}"
    do 
        #@todo figure out why we have to implement this crazy workaround
        LOCAL_LENGHT_OF_DIRECTORY_NAME=${#LOCAL_DIRECTORY_NAME} 
        if [[ $LOCAL_LENGHT_OF_DIRECTORY_NAME -gt 0 ]]
        then
            #begin of declaration
            LOCAL_DIRECTORY_NAME_AS_LOWERCASE=$(echo "$LOCAL_DIRECTORY_NAME" | tr A-Z a-z)
            LOCAL_DIRECTORY_NAME_AS_UPPERCASE=$(echo "$LOCAL_DIRECTORY_NAME" | tr a-z A-Z)
            declare -a LOCAL_POSSIBLE_ITEM_NAMES=( "$LOCAL_DIRECTORY_NAME" )

            if [[ "$LOCAL_DIRECTORY_NAME_AS_LOWERCASE" != "$LOCAL_DIRECTORY_NAME" ]]
            then
                LOCAL_POSSIBLE_ITEM_NAMES+=( "$LOCAL_DIRECTORY_NAME_AS_LOWERCASE" )
            fi

            if [[ "$LOCAL_DIRECTORY_NAME_AS_UPPERCASE" != "$LOCAL_DIRECTORY_NAME" ]]
            then
                LOCAL_POSSIBLE_ITEM_NAMES+=( "$LOCAL_DIRECTORY_NAME_AS_UPPERCASE" )
            fi
            #end of declaration

            #begin of create temporary directory
            if [[ ! -d "$LOCAL_TEMPORARY_DIRECTORY_NAME" ]]
            then
                mkdir "$LOCAL_TEMPORARY_DIRECTORY_NAME"
            fi
            #end of create temporary directory

            #begin of iteration over all possible argument names
            for LOCAL_POSSIBLE_ITEM_NAME in "${LOCAL_POSSIBLE_ITEM_NAMES[@]}"
            do 
                #@todo figure out why we have to implement this crazy workaround
                LOCAL_LENGHT_OF_POSSIBLE_ITEM_NAME=${#LOCAL_POSSIBLE_ITEM_NAME} 
                if [[ $LOCAL_LENGHT_OF_POSSIBLE_ITEM_NAME -gt 0 ]]
                then
                    LOCAL_NUMBER_OF_ENTRIES_FOR_POSSIBLE_ITEM_NAME=$(find . -maxdepth 1 -not -name ".*" -name "$LOCAL_POSSIBLE_ITEM_NAME?*" | wc -l)

                    #begin of moving available files into temporary directory
                    if [[ $LOCAL_NUMBER_OF_ENTRIES_FOR_POSSIBLE_ITEM_NAME -gt 0 ]]
                    then
                        #we found some files, so move it
                        mv "$LOCAL_POSSIBLE_ITEM_NAME"?* "$LOCAL_TEMPORARY_DIRECTORY_NAME/"
                    fi
                    #end of moving available files into temporary directory
                fi
            done
            #end of iteration over all possible argument names

            #begin of moving into real target directory
            if [[ "$(ls -A $LOCAL_TEMPORARY_DIRECTORY_NAME)" ]]
            then
                #directory is not empty
                if [[ ! -d "$LOCAL_DIRECTORY_NAME" ]]
                then
                    #create directory if it does not exist
                    mkdir "$LOCAL_DIRECTORY_NAME"
                fi

                #move files into it final directory
                mv "$LOCAL_TEMPORARY_DIRECTORY_NAME"/* "$LOCAL_DIRECTORY_NAME"
            fi
            #end of moving into real target directory
        fi
    done
    #end of iteration over all provided arguments

    #begin of clean up
    if [[ -d "$LOCAL_TEMPORARY_DIRECTORY_NAME" ]]
    then
        #remove temporary directory
        rmdir "$LOCAL_TEMPORARY_DIRECTORY_NAME"
    fi
    #end of clean up
}

#p

####
# Starts php's built in webserver
#
# [@param string $1 - directory that should be used as target, default is public]
# [@param int $2 - port the webserver should listen on, default is 80]
#
# @author stev leibelt <artodeto@bazzline.net>
# @since 2013-08-21
####
function net_bazzline_php_start_internal_webserver ()
{
    if [[ $# -eq 2 ]]; then
        DIRECTORY="$1";
        PORT="$2";
    elif [[ $# -eq 1 ]]; then
        DIRECTORY="$1";
        PORT=8080;
    else
        DIRECTORY="public";
        PORT=8080;
    fi

    /bin/env php -S 0.0.0.0:"$PORT" -t "$DIRECTORY"
}

#####
# Combines ps aux and grep
#
# @param string $1 - pattern your are searching for
#
# @author stev leibelt
# @since 2013-01-30
####
function net_bazzline_psgrep ()
{
    if [[ $# -eq 1 ]]; then
        ps aux | grep -i "$1"
    fi
}

#r

####
# refresh given interface
#
# @param string $1 - [optional] interface - default eth0
#
# @todo implement --verbose --list-interfaces
# @author stev leibelt
# @since 2013-04-30
####
function net_bazzline_refresh_interface ()
{
    LENGTH=${#NET_BAZZLINE_INTERFACES[@]}

    if [[ $LENGTH -eq 0 ]]; then
        echo 'Environment variable NET_BAZZLINE_INTERFACES not defined or empty'
        return 1
    fi

    if [[ $# -eq 0 ]]; then
        INTERFACE=${NET_BAZZLINE_INTERFACES[0]}
    else
        for NET_BAZZLINE_INTERFACE in "${NET_BAZZLINE_INTERFACES[@]}"
        do
            if [[ "$1" -eq $NET_BAZZLINE_INTERFACE ]]; then
                INTERFACE=$1
            fi
        done

        #set default if none is found
        INTERFACE=${INTERFACE:-$NET_BAZZLINE_INTERFACES[0]}
    fi

    sudo ip link set $INTERFACE down
    sudo ip link set $INTERFACE up
    sudo dhcpcd $INTERFACE
}

####
# Replaces a string in all files in given path and below
# taken from: http://www.cyberciti.biz/faq/unix-linux-replace-string-words-in-many-files/
# taken from: http://stackoverflow.com/questions/4437901/find-and-replace-string-in-a-file
# taken from: http://stackoverflow.com/questions/7450324/how-do-i-replace-a-string-with-another-string-in-all-files-below-my-current-dir
#
# @author stev leibelt <artodeto@bazzline.net>
# @since 2013-7-30
####
function net_bazzline_replace_string_in_files ()
{
    if [[ $# -lt 3 ]]; then
        echo 'invalid number of arguments provided'
        echo 'command search replace fileextension [path]'
        return 1
    fi

    SEARCH="$1"
    REPLACE="$2"
    FILE_EXTENSION="$3"

    if [[ $# -eq 4 ]]; then
        DIRECTORY_PATH="$4"
    else
        DIRECTORY_PATH="."
    fi

    find "$DIRECTPRY_PATH" -name "*.$FILE_EXTENSION" -type f -exec sed -i 's/'"$SEARCH"'/'"$REPLACE"'/g' {} \;
}

####
# @param string <path to zfs pool>
# [@param int number of snapshots to keep, default is 1]
# @todo
####
function net_bazzline_rotate_zfs_snapshot()
{
    echo 'work in progress'
}

####
# @param - rsync parameters
####
function net_bazzline_rsync ()
{
    rsync -aq --delete $@
}

#s

####
# @param string $SEARCH_PATTERN
# [@param int $MAXIMUM_LEVELS_OF_DIRECTORY_DEPTH]
####
function net_bazzline_search_in_composer_files()
{
    LOCAL_SEARCH_PATTERN="$1"

    if [[ $# -gt 1 ]]; then
        LOCAL_MAXIUM_LEVELS_OF_DIRECTORY_DEPTH=$2
    else
        LOCAL_MAXIUM_LEVELS_OF_DIRECTORY_DEPTH=2
    fi

    for LOCAL_FILE_PATH in $(find . -maxdepth $LOCAL_MAXIUM_LEVELS_OF_DIRECTORY_DEPTH -name composer.json); do
        echo "$LOCAL_FILE_PATH"
        cat "$LOCAL_FILE_PATH" | grep -i "$LOCAL_SEARCH_PATTERN"
    done
}

####
# @param string $PATH_TO_SSH_KEY
# @param string $SOURCE_HOST
# @param string $SOURCE_PATH
# @param string $DESTINATION_PATH
# @todo make PATH_TO_SSH_KEY optional
####
function net_bazzline_scp_from_host()
{
    if [[ $# -eq 4 ]]; then
        PATH_TO_SSH_KEY="$1"
        SOURCE_HOST="$2"
        SOURCE_PATH="$3"
        DESTINATION_PATH="$4"

        scp -r -i $PATH_TO_SSH_KEY $SOURCE_HOST:$SOURCE_PATH $DESTINATION_PATH
    else
        echo 'invalid number of arguments'
        echo '    net_bazzline_scp_from_host <path to ssh key> <source host> <source path> <destination path>'
    fi  
}

####
# @param string $PATH_TO_SSH_KEY
# @param string $DESTINATION_HOST
# @param string $SOURCE_PATH
# @param string $DESTINATION_PATH
# @todo make PATH_TO_SSH_KEY optional
####
function net_bazzline_scp_to_host()
{
    if [[ $# -eq 4 ]]; then
        PATH_TO_SSH_KEY="$1"
        DESTINATION_HOST="$2"
        SOURCE_PATH="$3"
        DESTINATION_PATH="$4"

        scp -r -i $PATH_TO_SSH_KEY $SOURCE_PATH $DESTINATION_HOST:$DESTINATION_PATH
    else
        echo 'invalid number of arguments'
        echo '    net_bazzline_scp_to_host <path to ssh key> <source host> <source path> <destination path>'
    fi  
}

####
# Takes a screenshot
# https://wiki.archlinux.org/index.php/Screenshot
#
# @param string $1 - [optional] filename with extension
#
# @author stev leiblt <artodeto@bazzline.net>
# @since 2013-05-25
####
function net_bazzline_screenshot ()
{
    if [[ $# -eq 0 ]]; then
        FILENAME='screenshot.jpg'
    else
        FILENAME="$1"
    fi

    import -window root $FILENAME
}

####
# sets the provided optical drive speed
# 
# @param int $1 - speed (default is 12)
# 
# @author stev leibelt <artodeto@bazzline.net>
# @since 2014-12-02
####
function net_bazzline_set_optical_drive_speed ()
{
    if [[ $# -eq 1 ]]; then
        SPEED="$1"
    else
        SPEED="12"
    fi

    eject -x $SPEED /dev/sr0
}

####
# Calls grep with "-ir --color=auto --exclude=\*.svn\* --exclude=\*.git\*" and directs errors to /dev/null
# All your provided parameters are passed to grep
#
# 
####
function net_bazzline_silent_grep ()
{
    if [[ $# -lt 1 ]]; then
        grep
    else
        grep -irI --color=auto --exclude=\*.svn\* --exclude=\*.git\* "$@" 2>/dev/null
    fi
}

####
# @param string $STRING
# @param string $SEARCH
# @return int (0 true, 1 false)
#
# @usage: 
#   if net_bazzline_string_contains 'foo' 'bar'; then
#       echo 'contains'
#   else
#       echo 'does not contain'
#   fi
#
# @see:
#   http://stackoverflow.com/questions/229551/string-contains-in-bash
#   http://stackoverflow.com/questions/6241256/what-is-proper-way-to-test-a-bash-function-return-value
# @author stev leibelt <artodeto@bazzline.net>
# @since 2015-11-05
####
function net_bazzline_string_contains()
{
    if [[ $# -eq 2 ]]; then
        CONTAINS=1
        STRING="$1"
        SEARCH="$2"

        case "$STRING" in 
           *"$SEARCH"*)
             CONTAINS=0
            ;;
        esac   

        return $CONTAINS
    else
        echo 'invalid number of arguments'
        echo '    net_bazzline_string_contains <string> <search>'
        return 1
    fi
}

####
# validates if string starts with given string or not
# 
# @param string $1 - string
# @param string $2 - needle
# 
# @author stev leibelt <artodeto@bazzline.net>
# @since 2014-07-31
####
function net_bazzline_string_starts_with ()
{
    if [[ $# -eq 2 ]]; then
        STRING="$1"
        SUB_STRING="$2"
        LENGTH_OF_SUB_STRING=${#SUB_STRING}
        STRING_WITH_SUB_STRING_ONLY=${STRING:0:$LENGTH_OF_SUB_STRING}

        if [[ $STRING_WITH_SUB_STRING_ONLY = $SUB_STRING ]]; then
            return 0
        else
            return 1
        fi
    else
        echo "Usage: net_bazzline_stringStartsWitch <string> <needle>"
        return 1
    fi
}

####
# use colordiff (if available)
# 
# @author stev leibelt
# @since 2014-12-09
# @see
#   http://zalas.eu/viewing-svn-diff-result-in-colors/
#   http://www.cyberciti.biz/programming/color-terminal-highlighter-for-diff-files/
####
function net_bazzline_svn_diff ()
{
    if [[ -x "/usr/bin/colordiff" ]]; then
        svn diff "${@}" | /usr/bin/colordiff
    else
        svn diff "${@}"
    fi
}

####
# calls svn log with limit and pipes content into a grep
#
# @param string $1 - pattern / what you search for
# @param integer $2 - svn log limit
#
# @author stev leibelt
# @since 2014-11-11
####
function net_bazzline_svn_log_grep ()
{
    if [[ $# -eq 1 ]]; then
        svn log --limit 1000 | grep -B2 "$1"
    elif [[ $# -eq 2 ]]; then
        svn log --limit "$2" | grep -B2 "$1"
    else
        echo 'invalid number of arguments supplied.'
        echo 'Usage:'
        echo 'net_bazzline_svn_log_grep <pattern:string> [<limit:int>]'
    fi
}

#####
# Calls svn diff for two repositories.
# Call $repositoryUrlOne $repositoryUrlTwo $filePath
# Use --summarize as default, so only filenames are shown
#
# @param string $1 - first repository
# @param string $2 - second repository
# @param string $3 - path of file to diff
# [@param string $4 - if set, summarize is disabled]
#
# @author stev leibelt
# @since 2013-01-30
####
function net_bazzline_svn_repository_diff ()
{
    if [[ $# -eq 3 ]]; then
        svn diff --summarize "$1""/""$3" "$2""/""$3"
    elif [[ $# -eq 4 ]]; then
        svn diff "$1""/""$3" "$2""/""$3"
    else
        echo 'No valid arguments supplied'
        echo 'repositoryUrlOne repositoryUrlTwo filePath [disableSummerize]'
    fi
}

####
# Uses rsync with ssh to copy data from remote to local host
#
# @param string $1 - remote user
# @param string $2 - remote host
# @param string $3 - source path on remote host
# @param string $4 - destination path on local host
# [@param string $5 - ssh key]
#
# @author stev leibelt <artodeto@bazzline.net>
# @since 2013-07-05
####
function net_bazzline_sync_from_host ()
{
    if [[ $# -eq 4 ]]; then
        USER="$1"
        HOST="$2"
        SOURCE="$3"
        DESTINATION="$4"

        rsync -aqz -e ssh $USER@$HOST:$SOURCE $DESTINATION
    elif [[ $# -eq 5 ]]; then
        USER="$1"
        HOST="$2"
        SOURCE="$3"
        DESTINATION="$4"
        KEY="$5"

        rsync -aqz -e ssh -i $KEY $USER@$HOST:$SOURCE $DESTINATION
    else
        echo 'invalid number of variables provided'
        echo 'command user host source destination'
        return 1
    fi
}

####
# Rsync with default values
#
# @author stev leibelt <artodeto@bazzline.net>
# @since 2013-12-21
####
function net_bazzline_sync_to ()
{
    if [[ $# -eq 0 ]]; then
        echo 'invalid number of variables provided'
        echo 'command [source one] [source ...] target'
        return 1
    elif [[ $# -eq 1 ]]; then
        rsync -aq . "$1"
    else
        rsync -aq $@
    fi
}

####
# Uses rsync with ssh to copy data from local to remote host
#
# @param string $1 - remote user
# @param string $2 - remote host
# @param string $3 - source path on local host
# @param string $4 - destination path on remote host
# [@param string $5 - ssh key]
#
# @author stev leibelt <artodeto@bazzline.net>
# @since 2013-07-05
####
function net_bazzline_sync_to_host ()
{
    if [[ $# -eq 4 ]]; then
        USER="$1"
        HOST="$2"
        SOURCE="$3"
        DESTINATION="$4"

        rsync -avz -e ssh $SOURCE $USER@$HOST:$DESTINATION
    elif [[ $# -eq 5 ]]; then
        USER="$1"
        HOST="$2"
        SOURCE="$3"
        DESTINATION="$4"
        KEY="$5"

        rsync -aqz -e ssh -i $KEY $SOURCE $USER@$HOST:$DESTINATION
    else
        echo 'invalid number of variables provided'
        echo 'command user host source destination'
        return 1
    fi
}

#t

####
# creates tar archvie
#
# @param string $1 - archvie name
# @param string $@ - paths
#
# @author stev leibelt
# @since 2013-07-19
####
function net_bazzline_tar_create ()
{
    if [[ $# -lt 2 ]]; then
        echo 'No valid arguments supplied.'
        echo 'archive path1 [pathX]'

        exit 1
    fi

    FILENAME="$1"

    # remove $1
    shift

    tar -cf $FILENAME "$@"
}

####
# extract content of a tar archvie
#
# @param string $1 - archvie name
#
# @author stev leibelt
# @since 2013-07-19
####
function net_bazzline_tar_extract ()
{
    if [[ $# -eq 1 ]]; then
        tar -xf "$1"
    else
        echo 'No valid arguments supplied.'
        echo 'archive'

        exit 1
    fi
}

####
# lists content of a tar archvie
#
# @param string $1 - archvie name
#
# @author stev leibelt
# @since 2013-07-19
####
function net_bazzline_tar_list ()
{
    if [[ $# -eq 1 ]]; then
        tar -tvf "$1"
    else
        echo 'No valid arguments supplied.'
        echo 'archive'

        exit 1
    fi
}

####
# create a file with a prefix of current date (Ymd)
#
# @param string $1 - file name you want to create
#
# @author stev leibelt
# @since 2014-09-20
####
function net_bazzline_touch_with_prefix_of_current_date ()
{
    if [[ $# -eq 1 ]]; then
        directoryName=`eval date +%y%m%d`"_$1"

        touch "$directoryName"
    else
        echo 'Should be called with exactly one parameter'
    fi
}

#u

####
# adds "." to the beginning of the directory or file name
#
# @author stev leibelt <artodeto@bazzline.net>
# @since 2014-07-31
####
function net_bazzline_unhide_file_system_object()
{
    if [[ $# -eq 1 ]]; then
        IDENTIFIER="$1";
# @todo validate if identifier is file or directory and if first character is "."
# @todo use net_bazzline_string_starts_with
        #if [[ net_bazzline_string_starts_with $IDENTIFIER "." ]]; then
            mv $IDENTIFIER ${IDENTIFIER:1};
            return 0
        #else
            #echo $IDENTIFIER" has to start with ."
            #return 1
    else
        echo "Usage: net_bazzline_unhide_directory <directory_name>"
        return 1
    fi
}

####
# @param string $zpool
# @param string $crypto name
# [@param string $crypto name]
# @author stev leibelt <artodeto@bazzline.net>
# @since 2015-03-15
# @todo implement support for multiple crypto names
####
function net_bazzline_unmount_luks_zpool ()
{
    if [[ $# -lt 3 ]]; then
        echo "usage: <command> <zpool> <crypto name> <zpool>"
        return 1
    else
        NAME="$2"
        ZPOOL="$1"

        sudo zpool export "$ZPOOL"
        sudo cryptsetup close "$NAME"
    fi
}

####
# @param string - mount point
####
function net_bazzline_unmount_sshfs ()
{
    echo "fusermount -u <mount point>"
    echo "rm -fr <mount point>"
}

#v

function net_bazzline_update_vim_bundles_and_plugins_with_vundle()
{
    LOCAL_PATH_TO_VUNDLE=$HOME'/.vim/bundle/Vundle.vim'

    #create directory if it does not exist
    if [[ ! -d "$LOCAL_PATH_TO_VUNDLE" ]]; then
        mkdir -p $LOCAL_PATH_TO_VUNDLE
    fi

    #clone vundle if directory is empty
    if [[ ! "$(ls -A $DIR_SELF)" ]]; then
        git clone https://github.com/VundleVim/Vundle.vim.git $LOCAL_PATH_TO_VUNDLE
    fi

    #install all available plugins
    vim +PluginInstall +qall & vim +BundleInstall +qall
}

#w

####
# lists all available process listening on given port
#
# @param integer $1 - port number
#
# @author stev leibelt <artodeto@bazzline.net>
# @since 2014-04-07
####
function net_bazzline_what_is_listening_on_that_port()
{
    if [[ $# -eq 1 ]]; then
        netstat -tulpn | grep --color :$1
    else
        echo "invalid number of arguments supplied"
        echo "portnumber"
        return 1
    fi
}
